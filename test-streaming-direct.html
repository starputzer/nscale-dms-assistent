<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direct Streaming Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        h1 {
            color: #333;
            margin-top: 0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        input, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }
        
        textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .secondary {
            background: #6c757d;
        }
        
        .secondary:hover {
            background: #545b62;
        }
        
        .success {
            background: #28a745;
        }
        
        .success:hover {
            background: #218838;
        }
        
        #output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 600px;
            overflow-y: auto;
        }
        
        #streamedMessage {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
            font-size: 14px;
            min-height: 50px;
        }
        
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        
        .metric-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 2px solid #dee2e6;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .tab:hover {
            background: #f8f9fa;
        }
        
        .tab.active {
            border-bottom-color: #007bff;
            color: #007bff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Direct Streaming Endpoint Test</h1>
        <p>Test the streaming endpoint directly without going through the Vue app to isolate backend/frontend issues.</p>
    </div>
    
    <div class="container">
        <div class="tabs">
            <div class="tab active" onclick="switchTab('streaming')">Streaming Test</div>
            <div class="tab" onclick="switchTab('comparison')">Non-Streaming Comparison</div>
            <div class="tab" onclick="switchTab('sse')">SSE Parsing Test</div>
        </div>
        
        <div id="streaming-tab" class="tab-content active">
            <h2>Test Streaming Endpoint</h2>
            
            <div class="form-group">
                <label for="question">Question:</label>
                <textarea id="question" placeholder="Enter your question here...">Was ist nscale?</textarea>
            </div>
            
            <div class="form-group">
                <label for="authToken">Auth Token (optional, will try localStorage):</label>
                <input type="text" id="authToken" placeholder="Bearer token or leave empty">
            </div>
            
            <div class="form-group">
                <label for="sessionId">Session ID (optional, will generate if empty):</label>
                <input type="text" id="sessionId" placeholder="test-session-123">
            </div>
            
            <div class="form-group">
                <label for="apiUrl">API URL:</label>
                <input type="text" id="apiUrl" value="http://localhost:5000/api/question/stream">
            </div>
            
            <button id="testStreamingBtn" onclick="runStreamingTest()">üöÄ Test Streaming</button>
            <button class="secondary" onclick="clearOutput()">üóëÔ∏è Clear Output</button>
            <button class="success" onclick="getAuthFromStorage()">üîë Get Auth from Storage</button>
            
            <div id="metrics" class="metrics" style="display: none;">
                <div class="metric">
                    <div class="metric-value" id="eventCount">0</div>
                    <div class="metric-label">Events</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="tokenCount">0</div>
                    <div class="metric-label">Tokens</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="duration">0</div>
                    <div class="metric-label">Duration (ms)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="avgTime">0</div>
                    <div class="metric-label">ms/token</div>
                </div>
            </div>
            
            <h3>Streamed Message:</h3>
            <div id="streamedMessage"></div>
        </div>
        
        <div id="comparison-tab" class="tab-content">
            <h2>Non-Streaming Comparison</h2>
            <p>Test the regular non-streaming endpoint to compare behavior.</p>
            
            <button onclick="runNonStreamingTest()">üîÑ Test Non-Streaming</button>
        </div>
        
        <div id="sse-tab" class="tab-content">
            <h2>SSE Parsing Test</h2>
            <p>Test Server-Sent Events parsing with sample data.</p>
            
            <button onclick="runSSEParsingTest()">üß™ Test SSE Parsing</button>
        </div>
    </div>
    
    <div class="container">
        <h2>Output Console</h2>
        <div id="output"></div>
    </div>
    
    <script>
        let startTime = 0;
        let eventCount = 0;
        let tokenCount = 0;
        
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput() {
            document.getElementById('output').textContent = '';
            document.getElementById('streamedMessage').textContent = '';
            document.getElementById('metrics').style.display = 'none';
            eventCount = 0;
            tokenCount = 0;
        }
        
        function updateMetrics() {
            document.getElementById('eventCount').textContent = eventCount;
            document.getElementById('tokenCount').textContent = tokenCount;
            const duration = Date.now() - startTime;
            document.getElementById('duration').textContent = duration;
            document.getElementById('avgTime').textContent = tokenCount > 0 ? (duration / tokenCount).toFixed(2) : '0';
        }
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }
        
        function getAuthFromStorage() {
            const token = localStorage.getItem('authToken');
            if (token) {
                document.getElementById('authToken').value = token;
                log('‚úÖ Found auth token in localStorage', 'success');
            } else {
                log('‚ùå No auth token found in localStorage', 'error');
            }
        }
        
        async function runStreamingTest() {
            clearOutput();
            
            const question = document.getElementById('question').value;
            const authToken = document.getElementById('authToken').value || localStorage.getItem('authToken');
            const sessionId = document.getElementById('sessionId').value || 'test-session-' + Date.now();
            const apiUrl = document.getElementById('apiUrl').value;
            
            log('=== Starting Streaming Test ===');
            log(`Question: ${question}`);
            log(`Session ID: ${sessionId}`);
            log(`API URL: ${apiUrl}`);
            log(`Auth: ${authToken ? 'Token provided' : 'No auth token'}`);
            
            const payload = {
                question: question,
                session_id: sessionId,
                context: [],
                stream: true
            };
            
            log('Request payload: ' + JSON.stringify(payload, null, 2));
            
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'text/event-stream',
            };
            
            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }
            
            log('Request headers: ' + JSON.stringify(headers, null, 2));
            
            document.getElementById('testStreamingBtn').disabled = true;
            document.getElementById('metrics').style.display = 'grid';
            document.getElementById('streamedMessage').textContent = '';
            
            try {
                startTime = Date.now();
                eventCount = 0;
                tokenCount = 0;
                
                log('üì° Sending request...');
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload),
                    credentials: 'include'
                });
                
                log(`Response status: ${response.status} ${response.statusText}`);
                
                // Log all response headers
                log('Response headers:');
                response.headers.forEach((value, key) => {
                    log(`  ${key}: ${value}`);
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`Error response: ${errorText}`, 'error');
                    return;
                }
                
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('text/event-stream')) {
                    log(`‚ö†Ô∏è Warning: Expected text/event-stream, got: ${contentType}`, 'error');
                    const text = await response.text();
                    log(`Response body: ${text}`);
                    return;
                }
                
                log('‚úÖ SSE stream started', 'success');
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        log('‚úÖ Stream ended', 'success');
                        break;
                    }
                    
                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        
                        if (line.startsWith('data: ')) {
                            eventCount++;
                            updateMetrics();
                            
                            const data = line.slice(6);
                            log(`Event ${eventCount}: ${data}`);
                            
                            try {
                                const parsed = JSON.parse(data);
                                
                                if (parsed.token) {
                                    tokenCount++;
                                    document.getElementById('streamedMessage').textContent += parsed.token;
                                    updateMetrics();
                                }
                                
                                if (parsed.done) {
                                    log('‚úÖ Stream complete signal received', 'success');
                                }
                                
                                if (parsed.error) {
                                    log(`Stream error: ${parsed.error}`, 'error');
                                }
                                
                            } catch (e) {
                                log(`Failed to parse JSON: ${e.message}`, 'error');
                            }
                        }
                    }
                }
                
                const finalDuration = Date.now() - startTime;
                log('\n=== Summary ===');
                log(`Total events: ${eventCount}`);
                log(`Total tokens: ${tokenCount}`);
                log(`Duration: ${finalDuration}ms`);
                log(`Average time per token: ${tokenCount > 0 ? (finalDuration / tokenCount).toFixed(2) : 'N/A'}ms`);
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
                log(`Stack: ${error.stack}`, 'error');
            } finally {
                document.getElementById('testStreamingBtn').disabled = false;
            }
        }
        
        async function runNonStreamingTest() {
            clearOutput();
            
            const question = document.getElementById('question').value;
            const authToken = document.getElementById('authToken').value || localStorage.getItem('authToken');
            const sessionId = document.getElementById('sessionId').value || 'test-session-' + Date.now();
            
            log('=== Non-Streaming Test ===');
            
            const url = 'http://localhost:5000/api/question';
            const payload = {
                question: question,
                session_id: sessionId,
                context: [],
                stream: false
            };
            
            const headers = {
                'Content-Type': 'application/json',
            };
            
            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }
            
            try {
                const startTime = Date.now();
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(payload),
                    credentials: 'include'
                });
                
                log(`Response status: ${response.status}`);
                const data = await response.json();
                log('Response: ' + JSON.stringify(data, null, 2));
                log(`Duration: ${Date.now() - startTime}ms`);
                
                if (data.answer) {
                    document.getElementById('streamedMessage').textContent = data.answer;
                }
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        }
        
        function runSSEParsingTest() {
            clearOutput();
            log('=== SSE Parsing Test ===');
            
            const sampleSSE = `data: {"token": "Hallo"}\n\ndata: {"token": ", "}\n\ndata: {"token": "ich "}\n\ndata: {"token": "bin "}\n\ndata: {"token": "ein "}\n\ndata: {"token": "KI-"}\n\ndata: {"token": "Assistent"}\n\ndata: {"done": true}\n\n`;
            
            log('Sample SSE data:');
            log(sampleSSE);
            
            const lines = sampleSSE.split('\n');
            let message = '';
            let eventNum = 0;
            
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    eventNum++;
                    const data = line.slice(6);
                    try {
                        const parsed = JSON.parse(data);
                        if (parsed.token) {
                            message += parsed.token;
                        }
                        log(`Event ${eventNum}: ${JSON.stringify(parsed)}`);
                    } catch (e) {
                        log(`Failed to parse: ${data}`, 'error');
                    }
                }
            }
            
            log(`\nReconstructed message: "${message}"`, 'success');
            document.getElementById('streamedMessage').textContent = message;
        }
        
        // Auto-load auth token on page load
        window.addEventListener('load', () => {
            const token = localStorage.getItem('authToken');
            if (token) {
                log('Found auth token in localStorage', 'success');
            }
        });
    </script>
</body>
</html>