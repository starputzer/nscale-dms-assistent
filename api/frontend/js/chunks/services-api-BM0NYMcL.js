var e=Object.defineProperty,t=(t,s,r)=>((t,s,r)=>s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[s]=r)(t,"symbol"!=typeof s?s+"":s,r);import{a as s}from"./vendor-axios-rSMZb3Ae.js";import{L as r,S as i}from"./services-D0Zg2F8x.js";import{v as a}from"./vendor-BRQMajHQ.js";var n={};const o={BASE_URL:n.VITE_API_BASE_URL||"/api",API_VERSION:n.VITE_API_VERSION||"v1",AUTH:{TOKEN_PREFIX:"Bearer",STORAGE_KEYS:{ACCESS_TOKEN:"nscale_access_token",REFRESH_TOKEN:"nscale_refresh_token",TOKEN_EXPIRY:"nscale_token_expiry",USER:"nscale_user"}},TIMEOUTS:{DEFAULT:3e4,UPLOAD:12e4,QUERY:1e4,TOKEN_REFRESH:5e3},RETRY:{MAX_RETRIES:3,BASE_DELAY:1e3,BACKOFF_FACTOR:1.5,RETRY_STATUS_CODES:[408,429,500,502,503,504],RETRY_NETWORK_ERRORS:!0},QUEUE:{MAX_CONCURRENT_REQUESTS:6,MAX_QUEUE_SIZE:100,PRIORITIES:{AUTH:100,USER_ACTION:80,FETCH:50,BACKGROUND:20}},RATE_LIMITING:{REMAINING_HEADER:"X-RateLimit-Remaining",RESET_HEADER:"X-RateLimit-Reset",LIMIT_HEADER:"X-RateLimit-Limit",THROTTLE_THRESHOLD:5,MIN_THROTTLE_DELAY:1e3},DEFAULT_PARAMS:{includeVersion:!0,responseType:"json"},STREAMING:{DEFAULT_SSE_CONFIG:{withCredentials:!0,heartbeatTimeout:6e4,retry:3e3},CONNECTION_TIMEOUT:1e4,STREAMING_ENDPOINTS:["/chat/stream","/sessions/:sessionId/stream"]},ENDPOINTS:{AUTH:{LOGIN:"/auth/login",LOGOUT:"/auth/logout",REFRESH:"/auth/refresh",USER:"/auth/user"},CHAT:{SESSIONS:"/sessions",SESSION:e=>`/sessions/${e}`,MESSAGES:e=>`/sessions/${e}/messages`,MESSAGE:(e,t)=>`/sessions/${e}/messages/${t}`,STREAM:e=>`/sessions/${e}/stream`},DOCUMENTS:{UPLOAD:"/documents/upload",CONVERT:"/documents/convert",DOCUMENT:e=>`/documents/${e}`},SYSTEM:{INFO:"/system/info",STATS:"/system/stats",HEALTH:"/system/health"},FEEDBACK:{SUBMIT:"/feedback"}},DEBUG:{VERBOSE:!1,LOG_REQUESTS:!1,COLORIZED_LOGGING:!0,INCLUDE_REQUEST_ID:!0}},h=(()=>{const e={...o};return e.DEBUG.VERBOSE=!1,e.DEBUG.LOG_REQUESTS=!1,e.RETRY.MAX_RETRIES=2,e})();class u{constructor(e={}){var s,i,a,n;t(this,"activeRequests",0),t(this,"queue",[]),t(this,"logService"),t(this,"maxConcurrent"),t(this,"maxQueueSize"),t(this,"queueTimeout"),t(this,"_isEnabled"),this.maxConcurrent=null!=(s=e.maxConcurrent)?s:h.QUEUE.MAX_CONCURRENT_REQUESTS,this.maxQueueSize=null!=(i=e.maxQueueSize)?i:h.QUEUE.MAX_QUEUE_SIZE,this.queueTimeout=null!=(a=e.queueTimeout)?a:3e4,this._isEnabled=null==(n=e.enabled)||n,this.logService=new r("RequestQueue")}get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled=e}get queueSize(){return this.queue.length}get activeRequestCount(){return this.activeRequests}async enqueue(e,t=0){if(!this._isEnabled)return e();if(this.activeRequests<this.maxConcurrent&&0===this.queue.length){this.activeRequests++;try{return await e()}finally{this.activeRequests--,this.processQueue()}}if(this.queue.length>=this.maxQueueSize){this.logService.warn(`Warteschlange ist voll (${this.queue.length}), verwerfe älteste Anfrage mit niedriger Priorität`);const e=this.findLowestPriorityIndex();if(!(e>=0&&this.queue[e].priority<t))throw new Error("Die Warteschlange ist voll und die Anfrage hat nicht ausreichend Priorität");this.queue.splice(e,1)[0].reject(new Error("Anfrage wurde aus der Warteschlange entfernt, da eine höherpriorisierte Anfrage einging"))}return new Promise(((s,r)=>{const i={priority:t,fn:e,resolve:s,reject:r,queuedAt:Date.now()};if(this.queueTimeout>0){const e=window.setTimeout((()=>{const e=this.queue.indexOf(i);-1!==e&&this.queue.splice(e,1),r(new Error(`Die Anfrage wurde nach ${this.queueTimeout}ms Wartezeit in der Warteschlange abgebrochen`))}),this.queueTimeout);i.timeoutId=e}this.queue.push(i),this.sortQueue(),this.logService.debug(`Anfrage mit Priorität ${t} zur Warteschlange hinzugefügt. Aktuelle Größe: ${this.queue.length}`),this.processQueue()}))}sortQueue(){this.queue.sort(((e,t)=>e.priority!==t.priority?t.priority-e.priority:e.queuedAt-t.queuedAt))}findLowestPriorityIndex(){if(0===this.queue.length)return-1;let e=this.queue[0].priority,t=0;for(let s=1;s<this.queue.length;s++)this.queue[s].priority<e&&(e=this.queue[s].priority,t=s);return t}processQueue(){if(this._isEnabled)for(;this.activeRequests<this.maxConcurrent&&this.queue.length>0;){const e=this.queue.shift();if(!e)break;e.timeoutId&&clearTimeout(e.timeoutId),this.activeRequests++,e.fn().then((t=>{e.resolve(t)})).catch((t=>{e.reject(t)})).finally((()=>{this.activeRequests--,this.processQueue()}))}}clear(){const e=new Error("Die Warteschlange wurde geleert und alle Anfragen abgebrochen");this.queue.forEach((t=>{t.timeoutId&&clearTimeout(t.timeoutId),t.reject(e)})),this.queue=[],this.logService.info("Warteschlange geleert")}pause(){this._isEnabled=!1,this.logService.info("Warteschlange pausiert")}resume(){this._isEnabled=!0,this.logService.info("Warteschlange fortgesetzt"),this.processQueue()}}class l{constructor(e={}){var s,i,a,n,o,u,l;t(this,"maxRetries"),t(this,"baseDelay"),t(this,"backoffFactor"),t(this,"retryStatusCodes"),t(this,"retryNetworkErrors"),t(this,"maxDelay"),t(this,"enableJitter"),t(this,"logService"),this.maxRetries=null!=(s=e.maxRetries)?s:h.RETRY.MAX_RETRIES,this.baseDelay=null!=(i=e.baseDelay)?i:h.RETRY.BASE_DELAY,this.backoffFactor=null!=(a=e.backoffFactor)?a:h.RETRY.BACKOFF_FACTOR,this.retryStatusCodes=null!=(n=e.retryStatusCodes)?n:h.RETRY.RETRY_STATUS_CODES,this.retryNetworkErrors=null!=(o=e.retryNetworkErrors)?o:h.RETRY.RETRY_NETWORK_ERRORS,this.maxDelay=null!=(u=e.maxDelay)?u:3e4,this.enableJitter=null==(l=e.enableJitter)||l,this.logService=new r("RetryHandler")}shouldRetry(e){var t,s,r,i;if(((null==(t=e.config)?void 0:t._retryCount)||0)>=this.maxRetries)return!1;if("canceled"===e.message)return!1;const a=null==(r=null==(s=e.config)?void 0:s.method)?void 0:r.toUpperCase();return!(a&&["POST","PATCH"].includes(a)&&!(null==(i=e.config)?void 0:i.isIdempotent))&&(e.response?this.retryStatusCodes.includes(e.response.status):this.retryNetworkErrors)}calculateDelay(e){let t=this.baseDelay*Math.pow(this.backoffFactor,e);if(t=Math.min(t,this.maxDelay),this.enableJitter){const e=.8+.4*Math.random();t=Math.floor(t*e)}return t}async retryRequest(e,t){var s;const r=(e._retryCount||0)+1;e._retryCount=r;const i=this.calculateDelay(r-1);return this.logService.info(`Wiederhole Anfrage (${r}/${this.maxRetries}) nach ${i}ms: ${null==(s=e.method)?void 0:s.toUpperCase()} ${e.url}`),await new Promise((e=>setTimeout(e,i))),t.request(e)}}class c{constructor(e={}){var s,i,a,n,o;t(this,"remainingHeader"),t(this,"resetHeader"),t(this,"limitHeader"),t(this,"throttleThreshold"),t(this,"minThrottleDelay"),t(this,"remainingRequests",{}),t(this,"resetTimes",{}),t(this,"limits",{}),t(this,"currentThrottleDelay",0),t(this,"lastRequestTime",0),t(this,"logService"),this.remainingHeader=null!=(s=e.remainingHeader)?s:h.RATE_LIMITING.REMAINING_HEADER,this.resetHeader=null!=(i=e.resetHeader)?i:h.RATE_LIMITING.RESET_HEADER,this.limitHeader=null!=(a=e.limitHeader)?a:h.RATE_LIMITING.LIMIT_HEADER,this.throttleThreshold=null!=(n=e.throttleThreshold)?n:h.RATE_LIMITING.THROTTLE_THRESHOLD,this.minThrottleDelay=null!=(o=e.minThrottleDelay)?o:h.RATE_LIMITING.MIN_THROTTLE_DELAY,this.logService=new r("RateLimitHandler")}updateFromResponse(e){const t=e.config.url||"",s=this.getBaseEndpoint(t),r=this.getHeaderValue(e.headers,this.remainingHeader),i=this.getResetTimeFromResponse(e),a=this.getHeaderValue(e.headers,this.limitHeader);null!==r&&(this.remainingRequests[s]=r),null!==i&&(this.resetTimes[s]=i),null!==a&&(this.limits[s]=a),!h.DEBUG.VERBOSE||null===r&&null===i&&null===a||this.logService.debug(`Rate-Limit für ${s}: ${r}/${a}, Reset: ${new Date(i||0).toISOString()}`),this.updateThrottleDelay()}getBaseEndpoint(e){const t=e.split("?")[0].split("/").filter(Boolean);return t.length>0&&t[0]===h.API_VERSION&&t.shift(),t.slice(0,Math.min(2,t.length)).join("/")||"default"}getHeaderValue(e,t){const s=e[t.toLowerCase()]||e[t];if(s){const e=parseInt(s,10);if(!isNaN(e))return e}return null}getResetTimeFromResponse(e){if(!e||!e.headers)return null;const t=e.headers[this.resetHeader.toLowerCase()]||e.headers[this.resetHeader];if(t){if(/^\d+$/.test(t)){return 1e3*parseInt(t,10)}try{const e=new Date(t);if(!isNaN(e.getTime()))return e.getTime()}catch(s){}try{const e=parseInt(t,10);if(!isNaN(e))return Date.now()+1e3*e}catch(s){}}return null}updateThrottleDelay(){let e=1/0,t=1/0;for(const s in this.remainingRequests){const r=this.remainingRequests[s];r<e&&(e=r,t=this.resetTimes[s]||1/0)}if(e<=this.throttleThreshold){const s=Math.max(0,t-Date.now());if(e<=0)this.currentThrottleDelay=s||this.minThrottleDelay;else{const t=1-e/this.throttleThreshold;this.currentThrottleDelay=Math.max(this.minThrottleDelay,Math.min(s,t*s))}this.logService.warn(`Rate-Limit fast erreicht (${e} verbleibend). Drosselung mit ${this.currentThrottleDelay}ms`)}else this.currentThrottleDelay=0}async applyThrottling(){if(this.currentThrottleDelay<=0)return;const e=Date.now()-this.lastRequestTime,t=Math.max(0,this.currentThrottleDelay-e);this.lastRequestTime=Date.now()+t,t>0&&(this.logService.debug(`Anfrage wird um ${t}ms verzögert (Rate-Limiting)`),await new Promise((e=>setTimeout(e,t))))}reset(){this.remainingRequests={},this.resetTimes={},this.limits={},this.currentThrottleDelay=0,this.lastRequestTime=0}getStatus(){return{remainingRequests:{...this.remainingRequests},resetTimes:{...this.resetTimes},limits:{...this.limits},currentThrottleDelay:this.currentThrottleDelay,lastRequestTime:this.lastRequestTime}}}class E{constructor(){t(this,"axiosInstance"),t(this,"requestQueue"),t(this,"retryHandler"),t(this,"rateLimitHandler"),t(this,"storageService"),t(this,"logService"),t(this,"isRefreshingToken",!1),t(this,"tokenRefreshQueue",[]),t(this,"refreshTokenPromise",null),this.axiosInstance=s.create({baseURL:h.BASE_URL,timeout:h.TIMEOUTS.DEFAULT,headers:{"Content-Type":"application/json",Accept:"application/json"}}),this.requestQueue=new u({maxConcurrent:h.QUEUE.MAX_CONCURRENT_REQUESTS,maxQueueSize:h.QUEUE.MAX_QUEUE_SIZE}),this.retryHandler=new l({maxRetries:h.RETRY.MAX_RETRIES,baseDelay:h.RETRY.BASE_DELAY,backoffFactor:h.RETRY.BACKOFF_FACTOR,retryStatusCodes:h.RETRY.RETRY_STATUS_CODES,retryNetworkErrors:h.RETRY.RETRY_NETWORK_ERRORS}),this.rateLimitHandler=new c({remainingHeader:h.RATE_LIMITING.REMAINING_HEADER,resetHeader:h.RATE_LIMITING.RESET_HEADER,limitHeader:h.RATE_LIMITING.LIMIT_HEADER,throttleThreshold:h.RATE_LIMITING.THROTTLE_THRESHOLD,minThrottleDelay:h.RATE_LIMITING.MIN_THROTTLE_DELAY}),this.storageService=new i,this.logService=new r("ApiService"),this.setupInterceptors()}setupInterceptors(){this.axiosInstance.interceptors.request.use((e=>{var t,s;const r=a();e.headers=e.headers||{},e.headers["X-Request-ID"]=r,h.DEBUG.LOG_REQUESTS&&this.logService.debug(`📤 Request [${null==(t=e.method)?void 0:t.toUpperCase()}] ${e.url}`,{requestId:r,headers:e.headers,params:e.params,data:e.data});const i=this.storageService.getItem(h.AUTH.STORAGE_KEYS.ACCESS_TOKEN);return i&&(e.headers.Authorization=`${h.AUTH.TOKEN_PREFIX} ${i}`),h.DEFAULT_PARAMS.includeVersion&&!(null==(s=e.url)?void 0:s.includes(`/${h.API_VERSION}/`))&&(e.url=`/${h.API_VERSION}${e.url}`),e}),(e=>(this.logService.error("❌ Request Error",e),Promise.reject(e)))),this.axiosInstance.interceptors.response.use((e=>(h.DEBUG.LOG_REQUESTS&&this.logService.debug(`📥 Response [${e.status}] ${e.config.url}`,{status:e.status,statusText:e.statusText,headers:e.headers,data:e.data}),this.rateLimitHandler.updateFromResponse(e),e)),(async e=>{var t,s,r,i,a,n;this.logService.error("❌ Response Error",{status:null==(t=e.response)?void 0:t.status,statusText:null==(s=e.response)?void 0:s.statusText,url:null==(r=e.config)?void 0:r.url,message:e.message,data:null==(i=e.response)?void 0:i.data});const o=e.config;return 401===(null==(a=e.response)?void 0:a.status)&&o&&!o._retry&&o.url!==h.ENDPOINTS.AUTH.REFRESH?this.handleUnauthorizedError(o):429===(null==(n=e.response)?void 0:n.status)?this.handleRateLimitError(e,o):o&&this.retryHandler.shouldRetry(e)?this.retryHandler.retryRequest(o,this.axiosInstance):Promise.reject(this.formatApiError(e))}))}async handleUnauthorizedError(e){e._retry=!0;try{const t=await this.refreshToken();return e.headers=e.headers||{},e.headers.Authorization=`${h.AUTH.TOKEN_PREFIX} ${t}`,this.axiosInstance(e)}catch(t){return this.logService.warn("🔑 Token refresh failed, clearing auth data",t),this.clearAuthData(),window.dispatchEvent(new CustomEvent("auth:unauthorized")),Promise.reject(t)}}async handleRateLimitError(e,t){var s;const r=null==(s=e.response)?void 0:s.headers["retry-after"],i=this.rateLimitHandler.getResetTimeFromResponse(e.response),a=r?1e3*parseInt(r,10):i?Math.max(0,i-Date.now()):h.RATE_LIMITING.MIN_THROTTLE_DELAY;return this.logService.warn(`🚦 Rate limited, retrying after ${a}ms`,{retryAfter:r,resetTime:i,url:t.url}),await new Promise((e=>setTimeout(e,a))),this.axiosInstance(t)}formatApiError(e){var t,r,i;if((null==(t=e.response)?void 0:t.data)&&e.response.data.error)return e.response.data.error;const a={code:"ERR_NETWORK",message:"Netzwerkfehler bei der Kommunikation mit dem Server",status:(null==(r=e.response)?void 0:r.status)||0};if("ECONNABORTED"===e.code)a.code="ERR_TIMEOUT",a.message="Die Anfrage hat das Zeitlimit überschritten";else if(e.message.includes("timeout"))a.code="ERR_TIMEOUT",a.message="Die Anfrage hat das Zeitlimit überschritten";else if(s.isCancel(e))a.code="ERR_CANCELLED",a.message="Die Anfrage wurde abgebrochen";else if(e.response){switch(a.status=e.response.status,e.response.status){case 400:a.code="ERR_BAD_REQUEST",a.message="Ungültige Anfrage";break;case 401:a.code="ERR_UNAUTHORIZED",a.message="Nicht autorisiert";break;case 403:a.code="ERR_FORBIDDEN",a.message="Zugriff verweigert";break;case 404:a.code="ERR_NOT_FOUND",a.message="Ressource nicht gefunden";break;case 409:a.code="ERR_CONFLICT",a.message="Konflikt mit dem aktuellen Zustand";break;case 422:a.code="ERR_VALIDATION",a.message="Validierungsfehler";break;case 429:a.code="ERR_RATE_LIMITED",a.message="Zu viele Anfragen, bitte warten Sie";break;case 500:a.code="ERR_SERVER",a.message="Interner Serverfehler";break;case 502:a.code="ERR_BAD_GATEWAY",a.message="Bad Gateway";break;case 503:a.code="ERR_SERVICE_UNAVAILABLE",a.message="Service nicht verfügbar";break;case 504:a.code="ERR_GATEWAY_TIMEOUT",a.message="Gateway-Timeout";break;default:a.code=`ERR_HTTP_${e.response.status}`,a.message=e.response.statusText||"Unbekannter HTTP-Fehler"}e.response.data&&("string"==typeof e.response.data?a.details={message:e.response.data}:a.details=e.response.data,(null==(i=e.response.data)?void 0:i.message)&&(a.message=e.response.data.message))}return h.DEBUG.VERBOSE&&(a.stack=e.stack),a}async refreshToken(){return this.refreshTokenPromise||(this.isRefreshingToken=!0,this.refreshTokenPromise=new Promise((async(e,t)=>{try{const t=this.storageService.getItem(h.AUTH.STORAGE_KEYS.REFRESH_TOKEN);if(!t)throw new Error("Kein Refresh-Token vorhanden");const s=await this.axiosInstance.post(h.ENDPOINTS.AUTH.REFRESH,{refreshToken:t},{_retry:!0});if(!s.data.success||!s.data.data)throw new Error("Token-Refresh fehlgeschlagen");const{accessToken:r,refreshToken:i,expiresAt:a}=s.data.data;this.storageService.setItem(h.AUTH.STORAGE_KEYS.ACCESS_TOKEN,r),this.storageService.setItem(h.AUTH.STORAGE_KEYS.REFRESH_TOKEN,i),this.storageService.setItem(h.AUTH.STORAGE_KEYS.TOKEN_EXPIRY,a),this.tokenRefreshQueue.forEach((({resolve:e})=>e(r))),this.tokenRefreshQueue=[],e(r)}catch(s){this.clearAuthData(),this.tokenRefreshQueue.forEach((({reject:e})=>e(s))),this.tokenRefreshQueue=[],t(s)}finally{this.isRefreshingToken=!1,this.refreshTokenPromise=null}}))),this.refreshTokenPromise}clearAuthData(){this.storageService.removeItem(h.AUTH.STORAGE_KEYS.ACCESS_TOKEN),this.storageService.removeItem(h.AUTH.STORAGE_KEYS.REFRESH_TOKEN),this.storageService.removeItem(h.AUTH.STORAGE_KEYS.TOKEN_EXPIRY),this.storageService.removeItem(h.AUTH.STORAGE_KEYS.USER)}async request(e,t,s={}){const r={...{method:e,url:t,retry:!0,refreshToken:!0,handleRateLimit:!0,showErrorToast:!0,priority:h.QUEUE.PRIORITIES.FETCH},...s};try{return this.requestQueue.isEnabled?await this.requestQueue.enqueue((()=>this.executeRequest(r)),r.priority):await this.executeRequest(r)}catch(i){const e=i;throw r.errorHandler&&r.errorHandler(e),r.showErrorToast&&this.showErrorToast(e),e}}async executeRequest(e){try{e.handleRateLimit&&await this.rateLimitHandler.applyThrottling();return(await this.axiosInstance.request(e)).data}catch(t){if(t instanceof Error)throw this.formatApiError(t);throw t}}showErrorToast(e){window.dispatchEvent(new CustomEvent("api:error",{detail:{message:e.message,code:e.code,status:e.status}}))}createCancelToken(){return s.CancelToken.source()}isCancel(e){return s.isCancel(e)}async get(e,t,s){return this.request("get",e,{...s,params:t})}async post(e,t,s){return this.request("post",e,{...s,data:t})}async put(e,t,s){return this.request("put",e,{...s,data:t})}async patch(e,t,s){return this.request("patch",e,{...s,data:t})}async delete(e,t){return this.request("delete",e,t)}async getPaginated(e,t,s){return this.get(e,t,s)}async uploadFile(e,t,s){const r=new FormData;if(r.append((null==s?void 0:s.fieldName)||"file",t),null==s?void 0:s.metadata)for(const[i,a]of Object.entries(s.metadata))r.append(i,"object"==typeof a?JSON.stringify(a):a.toString());return this.post(e,r,{...s,headers:{...null==s?void 0:s.headers,"Content-Type":"multipart/form-data"},timeout:h.TIMEOUTS.UPLOAD,onUploadProgress:null==s?void 0:s.onProgress})}async downloadFile(e,t){const s=await this.axiosInstance.get(e,{...t,responseType:"blob",timeout:h.TIMEOUTS.UPLOAD,onDownloadProgress:null==t?void 0:t.onProgress});if(null==t?void 0:t.filename){const e=window.URL.createObjectURL(new Blob([s.data])),r=document.createElement("a");r.href=e,r.setAttribute("download",t.filename),document.body.appendChild(r),r.click(),document.body.removeChild(r)}return s.data}async login(e){const t=await this.post(h.ENDPOINTS.AUTH.LOGIN,e,{priority:h.QUEUE.PRIORITIES.AUTH,refreshToken:!1});if(t.success&&t.data){const{accessToken:e,refreshToken:s,expiresAt:r,user:i}=t.data;this.storageService.setItem(h.AUTH.STORAGE_KEYS.ACCESS_TOKEN,e),this.storageService.setItem(h.AUTH.STORAGE_KEYS.REFRESH_TOKEN,s),this.storageService.setItem(h.AUTH.STORAGE_KEYS.TOKEN_EXPIRY,r),this.storageService.setItem(h.AUTH.STORAGE_KEYS.USER,JSON.stringify(i)),window.dispatchEvent(new CustomEvent("auth:login",{detail:{user:i}}))}return t}async logout(){try{await this.post(h.ENDPOINTS.AUTH.LOGOUT,null,{priority:h.QUEUE.PRIORITIES.AUTH,showErrorToast:!1}).catch((()=>{}))}finally{this.clearAuthData(),window.dispatchEvent(new CustomEvent("auth:logout"))}return{success:!0}}async refreshAuthToken(){return this.refreshToken()}isAuthenticated(){const e=this.storageService.getItem(h.AUTH.STORAGE_KEYS.ACCESS_TOKEN),t=this.storageService.getItem(h.AUTH.STORAGE_KEYS.TOKEN_EXPIRY);if(!e||!t)return!1;try{return new Date(t).getTime()>Date.now()}catch(s){return!1}}getUserInfo(){const e=this.storageService.getItem(h.AUTH.STORAGE_KEYS.USER);if(!e)return null;try{return JSON.parse(e)}catch(t){return null}}}new E;new class{constructor(e={}){t(this,"pendingRequests",[]),t(this,"pendingPromises",new Map),t(this,"batchTimeout",null),t(this,"requestCounter",0),t(this,"responseCache",new Map),t(this,"requestStats",{totalRequests:0,batchedRequests:0,savedRequests:0,totalBatches:0,errors:0,averageBatchSize:0,minBatchSize:1/0,maxBatchSize:0,cacheMissCount:0,cacheHitCount:0}),this.options=e,this.options={maxBatchSize:10,batchDelay:50,timeout:3e4,abortOnCriticalError:!0,batchEndpoint:"/api/batch",retries:2,retryDelay:1e3,enableCaching:!0,defaultCacheTTL:6e4,...e},this.startCacheCleanup()}addRequest(e){const t=this.generateCacheKey(e);if(this.options.enableCaching&&"GET"===e.method){const e=this.responseCache.get(t);if(e&&Date.now()-e.timestamp<e.ttl)return this.requestStats.cacheHitCount++,Promise.resolve(e.data);this.requestStats.cacheMissCount++}const s=e.id||"req_"+ ++this.requestCounter,r={...e,id:s};return this.requestStats.totalRequests++,this.pendingRequests.push(r),new Promise(((e,t)=>{this.pendingPromises.set(s,{resolve:e,reject:t,timestamp:Date.now()}),this.scheduleBatch()}))}scheduleBatch(){null!==this.batchTimeout&&clearTimeout(this.batchTimeout),this.pendingRequests.length>=(this.options.maxBatchSize||10)?this.sendBatch():this.batchTimeout=window.setTimeout((()=>{this.sendBatch()}),this.options.batchDelay||50)}async sendBatch(e=0){if(0===this.pendingRequests.length)return;this.requestStats.batchedRequests+=this.pendingRequests.length,this.requestStats.savedRequests+=this.pendingRequests.length-1,this.requestStats.totalBatches++,this.requestStats.minBatchSize=Math.min(this.requestStats.minBatchSize,this.pendingRequests.length),this.requestStats.maxBatchSize=Math.max(this.requestStats.maxBatchSize,this.pendingRequests.length),this.requestStats.averageBatchSize=this.requestStats.batchedRequests/this.requestStats.totalBatches;const t=[...this.pendingRequests];this.pendingRequests=[],this.batchTimeout=null;try{const e=await E.customRequest({url:this.options.batchEndpoint,method:"POST",data:{requests:t},timeout:this.options.timeout});this.processBatchResponse(e.data.responses,t)}catch(s){if(this.requestStats.errors++,e<(this.options.retries||0))return void setTimeout((()=>{this.pendingRequests.push(...t),this.sendBatch(e+1)}),this.options.retryDelay||1e3);this.rejectAllPendingRequests(t,s)}}processBatchResponse(e,t){const s=new Map;t.forEach((e=>s.set(e.id,e))),e.forEach((e=>{var t;const{id:r,success:i,data:a,error:n,status:o}=e,h=this.pendingPromises.get(r);if(!h)return;this.pendingPromises.delete(r);const u=s.get(r);if(i&&u&&"GET"===u.method&&this.options.enableCaching){const e=this.generateCacheKey(u),s=(null==(t=u.meta)?void 0:t.cacheTTL)||this.options.defaultCacheTTL||6e4;this.responseCache.set(e,{data:a,timestamp:Date.now(),ttl:s})}i?h.resolve(a):h.reject({status:o,message:n||"Unknown error",data:a})}))}rejectAllPendingRequests(e,t){e.forEach((e=>{const s=this.pendingPromises.get(e.id);s&&(s.reject({status:t.status||500,message:t.message||"Batch request failed",originalError:t}),this.pendingPromises.delete(e.id))}))}generateCacheKey(e){const t=e.endpoint+(e.params?"?"+new URLSearchParams(e.params).toString():"");return`${e.method||"GET"}:${t}`}startCacheCleanup(){setInterval((()=>{const e=Date.now();this.responseCache.forEach(((t,s)=>{e-t.timestamp>t.ttl&&this.responseCache.delete(s)})),this.pendingPromises.forEach(((t,s)=>{e-t.timestamp>3e5&&(t.reject({status:408,message:"Request timeout after 5 minutes"}),this.pendingPromises.delete(s))}))}),3e5)}async executeBatch(e){return Promise.all(e.map((e=>this.addRequest(e))))}async executeNamedBatch(e){const t=Object.entries(e).map((([e,t])=>this.addRequest(t).then((t=>({name:e,response:t})))));return(await Promise.all(t)).reduce(((e,{name:t,response:s})=>(e[t]=s,e)),{})}flushPendingRequests(){this.pendingRequests.length>0&&this.sendBatch()}invalidateCache(e){const t=this.generateCacheKey(e);this.responseCache.delete(t)}clearCache(){this.responseCache.clear()}getStats(){return{...this.requestStats}}};
